class BFS 
{
    field Maze maze;
    field Queue queue;
    field TwoDimensionalArray visited;
    field TwoDimensionalArray parentX; // x-координата родителя
    field TwoDimensionalArray parentY; // y-координата родителя
    field int startX, startY, exitX, exitY;
    field boolean found;
    field char Empty, Exit, Start, Wall;

    constructor BFS new(Maze m) 
    {
        let startX = 0;
        let startY = 1;
        let exitX = 14;
        let exitY = 13;
        let maze = m;
        let queue = Queue.new(300); //225 макс значений, но пусть +дополнительно
        let visited = TwoDimensionalArray.new(15, 15);
        let parentX = TwoDimensionalArray.new(15, 15);
        let parentY = TwoDimensionalArray.new(15, 15);
        let found = false;
        let Empty = " ";    // ASCII 32
        let Exit = "E";     // ASCII 69
        let Start = "S";    // ASCII 83
        let Wall = "W";     // ASCII 87
        return this;
    }
    
    method void initialize() 
    {
        var TwoDimensionalArray map;
        var int i, j;
        let i = 0;
        while (i < 15) 
        {
            let j = 0;
            while (j < 15) 
            {
                do visited.setIntValue(i, j, 0); // 0 = не посещено
                do parentX.setIntValue(i, j, -1); // -1 = нет родителя
                do parentY.setIntValue(i, j, -1);
                let j = j + 1;
            }
            let i = i + 1;
        }
        return;
    }
    
    method void run() 
    {
        var TwoDimensionalArray map;
        var int x, y;
        var String temp;  // Меняем обратно на String
        do initialize();
        do queue.enqueue(startY);
        do queue.enqueue(startX);
        let map = maze.getMap();
        while (~(queue.isEmpty()))
        {
            let y = queue.dequeue();
            let x = queue.dequeue();
            
            if (maze.IsValid(y, x)) {
                let temp = map.getStringValue(y, x);
                
                // DEBUG: Вывод текущей позиции и значения
                // do Output.printString("Checking position: ");
                // do Output.printInt(y);
                // do Output.printString(",");
                // do Output.printInt(x);
                // do Output.printString(" Value: ");
                // do Output.printString(temp);
                // do Output.println();

                if (visited.getIntValue(y, x) = 0) {
                    // Проверяем тип клетки: пробел (32), выход (69) или старт (83)
                    if ((temp.charAt(0) = 32) | (temp.charAt(0) = 69) | (temp.charAt(0) = 83)) {
                        do visited.setIntValue(y, x, 1);

                        // DEBUG: Вывод работы BFS
                        // do map.setStringValue(y, x, ".");
                        
                        
                        if ((x = exitX) & (y = exitY)) {
                            let found = true;
                            //do reconstructPath(); // Восстанавливаем путь
                            //do Output.moveCursor(0,0);
                            //do Output.printString("Exit found!");
                        }

                        // Проверяем соседей
                        // Вверх
                        if (maze.IsValid(y - 1, x)) {
                            let temp = map.getStringValue(y - 1, x);
                            // DEBUG: Проверка верхней клетки
                            // do Output.printString("Checking up: ");
                            // do Output.printString(temp);
                            // do Output.println();
                            if ((temp.charAt(0) = 32) | (temp.charAt(0) = 69)) {
                                if (visited.getIntValue(y - 1, x) = 0) {
                                    do parentX.setIntValue(y - 1, x, x); // Сохраняем родителя
                                    do parentY.setIntValue(y - 1, x, y);
                                    do queue.enqueue(y - 1);
                                    do queue.enqueue(x);
                                }
                            }
                        }

                        // Вниз
                        if (maze.IsValid(y + 1, x)) {
                            let temp = map.getStringValue(y + 1, x);
                            // DEBUG: Проверка нижней клетки
                            // do Output.printString("Checking down: ");
                            // do Output.printString(temp);
                            // do Output.println();
                            if ((temp.charAt(0) = 32) | (temp.charAt(0) = 69)) {
                                if (visited.getIntValue(y + 1, x) = 0) {
                                    do parentX.setIntValue(y + 1, x, x); // Сохраняем родителя
                                    do parentY.setIntValue(y + 1, x, y);
                                    do queue.enqueue(y + 1);
                                    do queue.enqueue(x);
                                }
                            }
                        }

                        // Влево
                        if (maze.IsValid(y, x - 1)) {
                            let temp = map.getStringValue(y, x - 1);
                            // DEBUG: Проверка левой клетки
                            // do Output.printString("Checking left: ");
                            // do Output.printString(temp);
                            // do Output.println();
                            if ((temp.charAt(0) = 32) | (temp.charAt(0) = 69)) {
                                if (visited.getIntValue(y, x - 1) = 0) {
                                    do parentX.setIntValue(y, x - 1, x); // Сохраняем родителя
                                    do parentY.setIntValue(y, x - 1, y);
                                    do queue.enqueue(y);
                                    do queue.enqueue(x - 1);
                                }
                            }
                        }

                        // Вправо
                        if (maze.IsValid(y, x + 1)) {
                            let temp = map.getStringValue(y, x + 1);
                            // DEBUG: Проверка правой клетки
                            // do Output.printString("Checking right: ");
                            // do Output.printString(temp);
                            // do Output.println();
                            if ((temp.charAt(0) = 32) | (temp.charAt(0) = 69)) {
                                if (visited.getIntValue(y, x + 1) = 0) {
                                    do parentX.setIntValue(y, x + 1, x); // Сохраняем родителя
                                    do parentY.setIntValue(y, x + 1, y);
                                    do queue.enqueue(y);
                                    do queue.enqueue(x + 1);
                                }
                            }
                        }
                    }
                }
            } 
        }
        return;
    }
    
    method void dispose() 
    {
        do queue.dispose();
        do visited.dispose();
        return;
    }

    method void reconstructPath() {
        var Drawer drawer;
        var TwoDimensionalArray map;
        var String star;
        var int currentX, currentY, prevX, prevY;
        let drawer = Drawer.new(maze);
        let map = maze.getMap(); // Получаем карту в отдельную переменную
        let star = String.new(1);
        do star.appendChar(42); // Создаем строку "*"
        
        let currentX = exitX;
        let currentY = exitY;
        
        while (~((currentX = startX) & (currentY = startY))) {
            // Используем переменную map вместо цепочки вызовов
            do map.setStringValue(currentY, currentX, star);
            
            // Анимация
            do Output.moveCursor(0, 0);
            do drawer.drawMaze();
            do Sys.wait(20);
            
            // Получаем родителя
            let prevX = parentX.getIntValue(currentY, currentX);
            let prevY = parentY.getIntValue(currentY, currentX);
            
            // Переходим к предыдущей клетке
            let currentX = prevX;
            let currentY = prevY;
        }
        
        do map.setStringValue(startY, startX, "S");
        return;
    }

    method boolean isFound() {
        return found;
    }
}
